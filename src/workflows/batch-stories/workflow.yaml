name: batch-stories
description: "Interactive batch selector for story-pipeline with complexity-based routing, smart wave ordering, and comprehensive session reporting."
author: "Jonah Schulte (leveraging BMAD Method)"

# Critical variables from config
# Config lives at {project-root}/_bmad/pantheon/config.yaml (ships with defaults; user can override).
# Artifacts live in _bmad-output/ (the standard BMAD output directory).
config_source: "{project-root}/_bmad/pantheon/config.yaml"
output_folder: "{project-root}/_bmad-output"
communication_language: "{config_source}:communication_language"
date: system-generated

# Sprint artifacts
sprint_artifacts: "{output_folder}/sprint-artifacts"
implementation_artifacts: "{output_folder}/implementation-artifacts"

# Workflow paths
# NOTE: After installation, Pantheon lives at {project-root}/_bmad/pantheon/
installed_path: "{project-root}/_bmad/pantheon/workflows/batch-stories"
instructions: "{installed_path}/workflow.md"

# State management
sprint_status: "{implementation_artifacts}/sprint-status.yaml"
batch_log: "{sprint_artifacts}/batch-stories-{date}.log"

# Variables
filter_by_epic: "" # Optional: Filter stories by epic number (e.g., "3" for only Epic 3 stories)
max_stories: 20 # Safety limit - won't process more than this in one batch
pause_between_stories: 5 # Seconds to pause between stories (allows monitoring, prevents rate limits)

# Global resource limits (M7 — prevent runaway consumption)
resource_limits:
  max_session_duration_hours: 8  # Hard stop for entire batch session
  max_agent_spawns: 300          # Cumulative agent spawns across all stories
  warn_at_agent_spawns: 200      # Emit warning when approaching limit

# Story-pipeline invocation settings
batch_settings:
  mode: "batch" # Always use batch mode for autonomous execution
  workflow_path: "{project-root}/_bmad/pantheon/workflows/story-pipeline"

# Story validation settings (NEW in v1.2.0)
validation:
  enabled: true # Validate story files before processing
  auto_create_missing: false # If true, auto-create without prompting (use with caution)
  auto_regenerate_invalid: false # If true, auto-regenerate without prompting (use with caution)
  min_sections: 12 # BMAD format requires all 12 sections
  min_current_state_words: 100 # Current State must have substantial content
  require_gap_analysis: true # Current State must have ✅/❌ markers
  backup_before_regenerate: true # Create .backup file before regenerating

# Story complexity scoring (NEW in v1.3.0)
# Routes stories to appropriate pipeline based on complexity
# Canonical tier definitions: src/agent-routing.yaml → complexity_routing
# This section defines scoring rules; tier definitions are in agent-routing.yaml.
complexity:
  enabled: true
  thresholds:
    micro: # Lightweight path: skip gap analysis + code review
      max_tasks: 3
      max_files: 5
      risk_keywords: [] # No high-risk keywords allowed
    standard: # Normal path: full pipeline
      max_tasks: 15
      max_files: 30
      risk_keywords: ["api", "service", "component", "feature"]
    complex: # Enhanced path: extra validation, consider splitting
      min_tasks: 16
      risk_keywords: ["auth", "security", "migration", "database", "payment", "encryption"]

  # Risk keyword scoring (adds to complexity)
  risk_weights:
    high: ["auth", "security", "payment", "encryption", "migration", "database", "schema"]
    medium: ["api", "integration", "external", "third-party", "cache"]
    low: ["ui", "style", "config", "docs", "test"]

  # Keyword matching configuration (defines how risk keywords are detected)
  keyword_matching:
    case_sensitive: false # "AUTH" matches "auth"
    require_word_boundaries: true # "auth" won't match "author"
    match_strategy: "exact" # exact word match required (no stemming)
    scan_locations:
      - story_title
      - task_descriptions
      - subtask_descriptions
    # Keyword variants (synonyms that map to canonical forms)
    variants:
      auth: ["authentication", "authorize", "authorization", "authz", "authn"]
      database: ["db", "databases", "datastore"]
      payment: ["payments", "pay", "billing", "checkout"]
      migration: ["migrations", "migrate"]
      security: ["secure", "security"]
      encryption: ["encrypt", "encrypted", "cipher"]

  # Task counting rules
  task_counting:
    method: "top_level_only" # Only count [ ] at task level, not subtasks
    # Options: "top_level_only", "include_subtasks", "weighted"
    # Example:
    # - [ ] Parent task       <- counts as 1
    #   - [ ] Subtask 1       <- ignored
    #   - [ ] Subtask 2       <- ignored

# Execution settings
execution:
  continue_on_failure: true # Keep processing remaining stories if one fails
  circuit_breaker:
    enabled: true
    max_consecutive_failures: 3  # Halt batch if 3 stories fail at the same phase
    same_phase_required: true    # Only triggers if failures are at the same pipeline phase
    action: "halt_and_report"    # Options: halt_and_report, warn_and_continue
  display_progress: true # Show running summary after each story
  save_state: true # Save progress to resume if interrupted

# Session reporting settings (NEW in v1.4.0)
session_reporting:
  enabled: true # Generate comprehensive session report at end
  output_dir: "{sprint_artifacts}/session-reports"
  include_sections:
    - executive_summary      # 2-3 paragraph narrative
    - features_delivered     # Per-story feature descriptions
    - technical_summary      # Files, tests, coverage tables
    - verification_guide     # Manual testing checklist
    - issues_and_debt        # Fixed and deferred issues
    - next_steps             # Follow-up actions
    - detailed_metrics       # Per-story breakdown (appendix)
  report_agent:
    name: "hermes"
    prompt_file: "{installed_path}/agents/session-reporter.md"
    subagent_type: "general-purpose"
    model: "sonnet"

# Parallel execution configuration (v5.0.0 — Lead-Driven Single-Story Workers)
# Replaces Agent Teams swarm with lead-managed background Task agents.
# Each worker is a background Task agent that processes ONE story in isolation.
# No shared task list, no inter-agent messaging, no self-scheduling.
parallel_config:
  max_workers: 3                # Maximum concurrent pipeline executors (background Task agents)
  worker_model: "opus"          # Model for pipeline executor agents
  worker_persona: "{installed_path}/agents/heracles.md"
  delegate_mode: recommended    # Use Shift+Tab delegate mode for the lead

  # Worktree isolation — persistent worktrees eliminate filesystem contention
  worktree_isolation:
    enabled: true
    max_worktrees: 3              # matches max_workers
    install_cmd: "npm ci"         # run once per worktree at setup
    branch_pattern: "worktree/heracles-{session}-{n}"  # {session} = unique 6-char hex per batch run
    worktree_path_pattern: ".claude/worktrees/heracles-{session}-{n}"
    integration_branch: "integration-{session}"        # session-scoped to avoid collision
    manifest_file: ".claude/worktrees/manifest.json"   # tracks active sessions for crash recovery
    colocate_dependencies: true   # stories with deps → same worktree
    orphan_detection:
      enabled: true               # check for orphaned worktrees at batch start
      stale_threshold_hours: 4    # sessions older than this with dead PID are orphans
      auto_cleanup: true          # automatically remove orphaned worktrees

  # -------------------------------------------------------------------------
  # ARCHITECTURE
  # -------------------------------------------------------------------------
  # Lead generates a 6-char session ID (hex from PID + timestamp) at batch start.
  # All worktree paths, branch names, and integration branch include the session ID.
  # This allows multiple terminals to run parallel batches without collision.
  #
  # Lead creates 3 persistent worktrees + integration branch (once):
  #   1. Check manifest for orphaned worktrees (dead PID + stale) → cleanup
  #   2. git worktree add for each worktree, npm ci once per worktree
  #   3. Write session to manifest.json (PID, timestamp, story assignments)
  #   4. Assign stories to worktrees (deps → same worktree, load-balance rest)
  #   5. Spawn ONE worker per story (not per worktree) — single-story contract
  #   6. When worker finishes: lead merges worktree → integration branch
  #   7. Lead spawns NEW worker in same worktree for next story in queue
  #   8. New worker pulls integration first → has all previously completed code
  #   9. Final merge: integration → main
  #  10. Remove session from manifest, cleanup worktrees and branches
  #
  # Each worker OWNS its worktree — no lock protocol, no staging contention.
  # Single-story workers stay focused. Worktrees persist (no re-setup).
  # Early integration catches cross-worktree issues before they compound.
  # Multiple terminals never collide — each has its own session-scoped worktrees.

  # -------------------------------------------------------------------------
  # ARTIFACT VALIDATION (Mandatory before accepting completion)
  # -------------------------------------------------------------------------
  # Lead validates these artifacts exist before marking a story complete:
  #   1. {story_key}-progress.json — status == SUCCESS or ALREADY_DONE
  #   2. {story_key}-builder.json — with file:line evidence in tasks_addressed
  #   3. {story_key}-argus.json OR {story_key}-review.json — reviewer artifact
  #   4. {story_key}-themis.json — triage data
  #   5. {story_key}-reconciler.json — task completion counts
  #   6. Git commit with feat({story_key}) prefix
  # Missing artifacts → rejection, re-queue for retry (max 2 attempts)

  # -------------------------------------------------------------------------
  # TIMEOUT & RECOVERY
  # -------------------------------------------------------------------------
  worker_retries: 2             # Retry failed/rejected stories (0 = no retry)
  circuit_breaker_threshold: 3  # Halt batch after 3 consecutive failures

standalone: true
web_bundle: false
